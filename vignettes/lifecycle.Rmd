---
title: "Using the lifecycle package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using the lifecycle package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

# Pretend we're in the lifecycle package
options("lifecycle:::calling_package" = "lifecycle")
```

lifecycle provides a standard way to document the lifecycle stage of functions are arguments, and tools to encourage users away from deprecated functions.
In brief:

1.  Insert badges in your roxygen2 documentation by calling `lifecycle::badge()`:

    ```{r}
    #' `r lifecycle::badge("experimental")`
    ```

2.  If a function or argument is deprecated, generate a user-friendly warning or error with `deprecate_soft()`, `deprecate_warn()`, or `deprecate_stop()`.

Before you begin, make sure that you're familiar with the lifecycle stages, as described in `vignette("stages")`.

```{r setup}
library(lifecycle)
```

## Documentation badges {#rd-badges}

Experimental, questioning, superseded, and deprecated (including soft-deprecated and defunct functions) should be clearly labelled in the document with a badge:

-   Call `usethis::use_lifecycle()` to embed the badge images in your package.
    (You only need to do this once)

-   Then use `lifecycle::badge()` to insert a badge:

    ```{r, eval = FALSE}
    #' `r lifecycle::badge("experimental")
    #' `r lifecycle::badge("deprecated")
    #' `r lifecycle::badge("superseded")
    ```

    This will show an image in HTML documentation, and text elsewhere.

-   To document the status of a whole function, a good place to include the badge is at the top of the `@description` block.
    To document an argument, you can put the badge in the argument description.
    You should also include a brief description of why the function is in that state.

-   For superseded and deprecated functions, rewrite the examples showing how to translate from the old to new syntax.

-   For deprecated functions, add `@keywords internal` and update `_pkgdown.yaml` (if you use pkgdown), so that they're no longer listed in documentation indexes.

`lifecycle::badge()` is only used by roxygen2, so this is a build-time dependency.
If you don't use the deprecation functions below, you don't need to import or suggest the lifecycle package.

## Warnings and errors

Deprecated functions should clearly signal their deprecation status.
There are three levels of verbosity:

-   **Soft deprecation**: Call `deprecate_soft()` to start warning users about the deprecation in the least disruptive way.
    This function only warns (a) users who try the feature from the global workspace (at most once every 8 hours), and (b) developers who directly use the feature (when running testthat tests).
    No warning is when the deprecated feature is called indirectly by another package.

-   **Deprecation**: Call `deprecate_warn()` to warn unconditionally about the deprecated feature.
    The warning is issued only once every 8 hours.

-   **Defunct**: Call `deprecate_stop()` to fail with an error.

Most functions only need deprecation; you only need soft deprecation and or defunct for particularly important or widely used functions.

### Functions

The first two arguments give the version where deprecation occurred[^1] and a description of what is deprecated:

[^1]: If the function goes through multiple deprecation stages, this stays the same.

```{r}
deprecate_warn("1.0.0", "foo()")
```

Where possible, describe the replacement in the third argument:

```{r}
deprecate_warn("1.0.0", "foo()", "new()")
```

(Note that the message includes the package name --- this is automatically discovered from the environment of the calling function).

For example, if you renamed a function, you might write something like:

```{r}
# The new replacement
foobar_adder <- function(foo, bar) {
  foo + bar
}

# The old function still exported for compatibility
foobaz_adder <- function(foo, bar) {
  deprecate_warn("1.0.0", "foobaz_adder()", "foobar_adder()")
  foobar_adder(foo, bar)
}
```

### Arguments

The syntax for deprecating arguments is similar:

```{r}
deprecate_warn("1.0.0", "foo(arg = )")

deprecate_warn("1.0.0", "foo(arg = )", "foo(new = )")
```

An argument can be partially deprecated by disallowing certain input types:

```{r}
deprecate_warn("1.0.0", "foo(arg = 'must be a scalar integer')")
```

lifecycle also provides the `deprecated()` sentinel to use as a default argument.
This makes the deprecation self-documenting and allows external tools to determine which arguments are deprecated.
You can test whether or not the argument was supplied by using `lifecycle::is_present()`:

```{r}
foobar_adder <- function(foo, bar, baz = deprecated()) {
  # Check if user has supplied `baz` instead of `bar`
  if (lifecycle::is_present(baz)) {

    # Signal the deprecation to the user
    deprecate_warn("1.0.0", "foobar_adder(baz = )", "foobar_adder(bar = )")

    # Deal with the deprecated argument for compatibility
    bar <- baz
  }

  foo + bar
}
```

### Other

If the behaviour your deprecating or suggested alternative doesn't fall into the forms shown above, you can use the `details` argument instead of `with`.
This argument allows you to supply the message that will be shown to the user, giving you total freedom.
For example, `usethis::use_pkg_travis()` was deprecated in favour of calling another function with a specific argument.
Its code looks something like this:

```{r}
use_pkgdown_travis <- function() {
  lifecycle::deprecate_warn(
    when = "2.0.0",
    what = "usethis::use_pkgdown_travis()",
    details = 'We recommend `use_github_action("pkgdown")` for new pkgdown setups.'
  )
  ...
}
```

## Workflow

### Bumping deprecation stage

Some manual search and replace is needed to bump the status of deprecated features.
We recommend starting with defunct features and working your way up:

1.  Search for `deprecate_stop()` and remove the feature from the package.
    The feature is now archived.

2.  Search for `deprecate_warn()` and replace with `deprecate_stop()`.

3.  Search for `deprecate_soft()` and replace with `deprecate_warn()`.

4.  Call `deprecate_soft()` from newly deprecated functions.

Don't forget to update the badges in the documentation topics.

### Test deprecated features

To fully test a deprecated function you need to do two things:

-   Check that the deprecated behaviour still works.

    ```{r, eval = FALSE}
    test_that("`baz` argument of `foobar_adder()` still works", {
      withr::local_options(lifecycle_verbosity = "quiet")
      foobar_adder(1, baz = 2)
    })
    ```

-   Check that the deprecated behaviour generates a deprecation warning.

    ```{r, eval = FALSE}
    test_that("`baz` argument of `foobar_adder()` is deprecated", {
      expect_deprecated(foobar_adder(1, baz = 2))
    })

    test_that("`foo()` is defunct", {
      expect_defunct(foo())
    })
    ```

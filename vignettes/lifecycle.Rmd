---
title: "Using the lifecycle package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using the lifecycle package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Use lifecycle to document the status of your exported functions and arguments.
It provides a standard way to describe lifecycle stage in the documentation, and tools to encourage users away from deprecated functions.
Before you begin, make sure that you're familiar with the lifecycle stages, as described in `vignette("stages")`.

```{r setup}
library(lifecycle)
```

In brief:

1.  Insert the relevant badge in your roxygen documentation by calling `lifecycle::badge()` within R backticks:

        `r lifecycle::badge("experimental")`
        `r lifecycle::badge("deprecated")`
        `r lifecycle::badge("superseded")`

2.  If a function or argument is deprecated, make sure your users know about by calling `deprecate_soft()`, `deprecate_warn()`, or `deprecate_stop()`.

## Documentation bages {#rd-badges}

Experimental, questioning, superseded, and deprecated (including soft-deprecated and defunct functions) should be clearly labelled in the document with a badge:

-   Call `usethis::use_lifecycle()` to import the badges in your package.
    Then use `lifecycle::badge()` to insert a badge:

    ```{r, eval = FALSE}
    #' `r lifecycle::badge("experimental")
    #' `r lifecycle::badge("deprecated")
    ```

    This badge renders as text in non-HTML documentation.
    To document the status of a whole function, a good place to include the badge is at the top of the `@description` block.
    To document an argument, you can put the badge in the argument description.

    `lifecycle::badge()` is only ran by roxygen, so this is a build-time dependency.
    You don't need to import lifecycle just to include badges in your documentation.

-   You should also include a brief description of why the function is in that state.

-   For superseded and deprecated functions, rewrite the examples showing how to translate from the old to new syntax.

-   For deprecated functions, add `@keywords internal` and update `_pkgdown.yaml` (if you use pkgdown), so that they're no longer listed in documentation indexes.

## Warnings and errors

Deprecated functions should clearly signal their deprecation status.
There are three levels of verbosity:

-   **Soft deprecation**: Call `deprecate_soft()` to start warning users about the deprecation in the least disruptive way.
    This function only warns (a) users who try the feature from the global workspace (at most once every 8 hours), and (b) developers who directly use the feature (when running testthat tests).
    No warning is when the deprecated feature is called indirectly by another package.

-   **Deprecation**: Call `deprecate_warn()` to warn unconditionally about the deprecated feature.
    The warning is issued only once every 8 hours.

-   **Defunct**: Call `deprecate_stop()` to fail with an error.

The following sections describe the details when deprecating functions and arguments.

### Functions

The first two arguments give the version where deprecation occurred[^1] and a description of what is deprecated:

[^1]: If the function goes through multiple deprecation stages, this stays the same.

```{r}
deprecate_warn("1.0.0", "mypkg::foo()")
```

Where possible, describe the replacement in the third argument:

```{r}
deprecate_warn("1.0.0", "mypkg::foo()", "new()")
```

We explicitly mention the namespace in these examples, but you can typically omit the namespace because lifecycle will infer it from the calling environment.
Specifying the namespace is mostly useful when the replacement is implemented in a different package.

```{r}
# The new replacement
foobar_adder <- function(foo, bar) {
  foo + bar
}

# The old function still exported for compatibility
foobaz_adder <- function(foo, bar) {
  deprecate_warn("1.0.0", "foobaz_adder()", "foobar_adder()")
  foobar_adder(foo, bar)
}
```

### Arguments

The syntax for deprecating arguments is similar:

```{r}
deprecate_warn("1.0.0", "mypkg::foo(arg = )")

deprecate_warn("1.0.0", "mypkg::foo(arg = )", "mypkg::foo(new = )")
```

An argument can be partially deprecated by disallowing certain input types:

```{r}
deprecate_warn("1.0.0", "mypkg::foo(arg = 'must be a scalar integer')")
```

lifecycle also provides the `deprecated()` sentinel to use as default argument.
This provides self-documentation for your users and makes it possible for external tools to determine which arguments are deprecated.
Test whether the argument was supplied by the caller with `lifecycle::is_present()`:

```{r}
foobar_adder <- function(foo, bar, baz = deprecated()) {
  # Check if user has supplied `baz` instead of `bar`
  if (lifecycle::is_present(baz)) {

    # Signal the deprecation to the user
    deprecate_warn("1.0.0", "foobar_adder(baz = )", "foobar_adder(bar = )")

    # Deal with the deprecated argument for compatibility
    bar <- baz
  }

  foo + bar
}
```

## Workflow

### Bumping deprecation stage

Some manual search and replace is needed to bump the status of deprecated features.
We recommend starting with defunct features and work your way up:

1.  Search for `deprecate_stop()` and remove the feature from the package.
    The feature is now archived.

2.  Search for `deprecate_warn()` and replace with `deprecate_stop()`.

3.  Search for `deprecate_soft()` and replace with `deprecate_warn()`.

4.  Call `deprecate_soft()` from newly deprecated functions.

Don't forget to update the badges in the documentation topics.

### Test deprecated features

Test whether a deprecated feature still works by setting `lifecycle_verbosity` to `"quiet"`:

```{r, eval = FALSE}
test_that("`baz` argument of `foobar_adder()` still works", {
  withr::local_options(list(lifecycle_verbosity = "quiet"))
  foobar_adder(1, baz = 2)
})
```

You can also set up verbosity for a whole testthat file within `setup()` and `teardown()` blocks:

```{r, eval = FALSE}
setup(options(lifecycle_verbosity = "quiet"))
teardown(options(lifecycle_verbosity = NULL))
```

Test that a feature is correctly deprecated with `expect_deprecated()` or `expect_defunct()`:

```{r, eval = FALSE}
test_that("`baz` argument of `foobar_adder()` is deprecated", {
  expect_deprecated(foobar_adder(1, baz = 2))
})

test_that("`foo()` is defunct", {
  expect_defunct(foo())
})
```

More control over verbosity can be exercised with the `lifecycle_verbosity` option.
See `?verbosity`.
